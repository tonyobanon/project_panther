
I introduced a system property "bootstage.scanProtectionContext"
to bypass constraint in ThreadSecurity.setInstance(..)
When adding the permission sets, this should be taken note of

///////////////////////////

Should ClientRBRef bw supported as a column type?

For properties that are lists and maps
try to add a default

Add a feature on QOpt that allows only items with specific attribute values
to be projected in. This will help us optimize these indexes

In the DB Api, add helper annotation table fields, i.e
1. Serialize
2. Auto generated

////////////////////////////


Figure out unload() in SpiDelegate

The credentials path is broken in GoogleHelper:31

When provisioning apps, eargerly load all classes
into the app's class loader

Use static analysis to process @Final annotation. This prevents
children of an interface from overriding a method, even though
it is valid in the Jvm

Implement the CodeSecurity class

Finish work on DelegateInitResult in SpiDelegateHandler
Finish work on Resource


Properly group singletons because I can see that some classes
work together e.h the SPI implementations

Stop using Platform Internal

Moving forward, use collections from http://www.magicwerk.org/page-collections-overview.html

These components needs DB:
1. User defined permissions
2. SpiBase's trusted app list



A new attack vector:
1. A malicious resource class is created
2. It prevents being loaded by using a different class name
3. It attempts to use the SpiDelegate's rMap
4. The SPI delegate grants it access because of its type
5. It fills up the rMap's space

When Fusion request come in, inorder we get the appId
and check

Modify qopt tools to use the adapter delegate's cache

Add migration logic for all AdapterLogic

Work on UIContext

Write logic to determine if Platform is installed
Also, introspect getResourcePath() -> Do we need to create it ahead of time?

Build Internal Code Generator that works based using predefined annotations, see ThreadSecurity.verify()

Integrate Apache solr (if it's compatible with Jvm FileSystemProvider)

determine if item count can be added to the index description in the Database API

create a user-facing seetings that helps describes the provisioned throughput, as this is not part of the Database API

use JsonParser singleton instead of GsonFactory

Implement migration for all adapters

Add security manager for new File(..)

Replace gson.JsonObject with fusion

Go through delegate and ensure that they are consuming resources in init().. 

Simplify enum.from

On installation, detect that the user is an admin

I noticed that delegates have not been using createResourceMaps()..


apps, adapter_config, spi_config, crypto, web_assets

Note: properly synchrionize when writing to above files

** Clustering scenarios
1. If a master leaves, the slaves should rejoin


** ThreadSecurity scenarios
1. When clustering and serving Http requests, manage how
   threads are marked as secure

Add Platform SpiDelegate


###	CREATING AN ADAPTER TYPE

*  Note: Only trusted can create

1. Update the AdapterType enum by adding a new constant
   
2. Create an interface that implements the Adapter class. 
   Then add relevant method signatures / static method(s).
   You also need to override getType() method
   
3. Create the delegate and it's abstract super class (that 
   directly extends AbstractAdapterDelegate)
   AbstractAdapterDelegate
   
5. If you need to extend the AdapterConfig class inorder,
   to store and load your configuration files remeber to
   use the AdapterType created in step 1



Rewrite the init function of delegates of better take advantage of DelegateInitResult

Add option in BaseEvt to indicate that no more than one listener should be registered

CEA-1 SpiDelegate.init() should return an object, this is important because there are scenarios where the delegate needs more information to continue


finish up services for fs,cache,db,crypto
Implement ability to route request in the cluster. Also, take service affinity into consideration

Ensure that all calls to getDelegate(..) have a cached local copy

Realm Consolidation
References of Class.getName()
Factor in platform updates as part of classpath scanning workflow
In Database setup, use a static method to retrieve Calcite schema factory

A lot of work has to go into rendering of forms, and ability to add custom helpers to customize rendering.

Create more fs adapters, Google Drive, Amazon s3, JimFs
Create more db adapters, MySQL, postgres, oracle , create a SQLAdapter super class, and just override name, title, logo


* - Prototype Available, but not feature complete
# - Work in progress

Security Manager / Permissions (Create more permission sets) *
SPI Delegate start *
Clustering *
Realms: forms, functionality, Consolidate Form field repository #
Listable.authenticate still uses RoleModel.isAccessAllowed, fix this
Move spec.baseObjectType
Implement ObjectUtils.serialize/deserialize
Implement session invalidation
Implement CacheBackedMap (sessions depend on this)


When adding to Cache, we need to map appId to key due to the reason below:
We will need to flush out all entries for an app in the cache, when the app is updated.
This is because class definitions may change, and as such we may no longer be able to correctly
deserialize existing entries


Generally stop using class.getName(). To do this, scan for references, and find an alternative


Some Javax Packages are missing in Java 10


For string spliting, use patterns, instead of the String class for performance


Shared Libraries
NoSQL-like API on top of javax.sql.Connection ?

IModels


Models Rewrite

Platform Start Plan

UI
SPI Hot Reloading
Cluster Orchestration
Load Balancing
Metrics

Properly setup FontCaching for PDFBox


ServiceDelegate should work with ThreadSecurity to smartly decide which threads
are trusted



APPS TO BUILD
1. Real Estate 
2. Accounting -> OfBiz
3. Education
4. Ecommerce -> Konakart
5. CRM
6. HR
7. Manufacturing
8. Insurance



Make most methods in AbstractSpiDelegates to be final


Read Configurations
Load client assets


The workflow for starting master:
1. The user enters IAM credentials on CE website
2. CE starts the master node, passing the same credentials as Instance Tags

3. Pre-Install phase continues inside the node (for masters only)
4. In Screen 1, the user enters DB credentials, the response is saved to DB_PROFILE_FILE
5. In Screen 2, the user enters Cache credentials, the response is saved to CACHE_PROFILE_FILE
6. In Screen 3, the user enters FileSystem credentials, the response is saved to FS_PROFILE_FILE, then call FileSystemProviderImpl.init()
   will get notified
7. In Screen 4, the user enters KeyStore info, used for Https, document signing, e.t.c

8. In Screen 5,

After these have saved, the platform is restarted

8. Post-Install phase continues, here the user enters things like company information
9. The data is saved and the user is redirected to the dashboard


FileSystemProvider should add a prefix for paths




The workflow for app extraction:
1. From the marketplace, apps come as a bundled file.
2. The platform knows how to collapse the single bundled file, into seperate files
3. Then using the encrypted file system, we save the classes


Note: credentials should be passed as instance tags to auto scaled slaves


Make sure to set Thread.contextLoader (to an AppClassLoader instance) for apps, else leave it as null

We assume that classes with a AppClassLoader is a third party -> SpiDelegateHandlerImpl->isInternalDelegate


Applications should be forbidden from creating new Threads on their own,
a method should be created for them to use as an alternative


As a general rule, apps should be unable to extend Jvm Services, i.e no META-INF folder


Many times, Runtime Exceptions are thrown without using Error Objects.. Fix


In @interface EventListener, add property that indicates releveant roles





NAME		  CREDENTIAL SOURCE

Compute			 -
DB			Inherit
Caching			Init form
File System		Inherit



Font Caching
Client Assets (Store in Memory instead)
PDF
Config (DB, FS, CACHE)



SCREEN ATTRIBUTES
Route based-> Fusion
Hierarchical -> routes_mapping.json

Templating -> TemplateObjectModel
Partial Rendering -> realignite
Pre bundled components


Stress Test sequence


Seggragate APIs
Move errors and functionalities to their relevant packages


complete Realms, fields, and functionalities
complete FusionHelper


In RoleModel::init(), roles to functionality mappings should be registered in
RealmDelegate, and should be incrementally updated


ORGANIZATION_ID: {params}.abc
ORGANIZATION_ID: {headers}.abc
ORGANIZATION_ID: {body}.abc.def.ghi


Impl CacheBackedMap
Start using delegate resource maps for everything


Make Cloud-based config params visible in Cloud Environment:
 Cache, Storage, ClusterRole

By default, inMemory() in SpiDelegate to fetch Cloud environment

Check if delegate is respecting the setting in Cloud Environment
		
Add Logger SpiType as autmatic dependency for all delegates
		




FormModel should call realm delegate for predefined form sections

Decentralize FormFieldRepository



CREATE TABLE
CREATE INDEX
Write TableModify Rule
Modify Filter Rule
Write more rules for the adapter

TimeTrends, IModels, Model Versioning, 
Virtual Host Configuration, KeyStoreManager


Jdbc, Fusion

Disable Assertions on Production


Scan SPIs (i.e. Table, CloudEnvironment)
Is Database Selected (Read Instance Meta file)?
Is Cache Selected (Read Instance Meta file)?
If yes, Start all SPIs, Launch Dashboard
If no, Start only Service and UI Spis, Launch DatabaseSetup/CacheSetup, Start all SPIs, Launch Dashboard
Call Hooks


database_profile


{
 
}


Migrate from Reflection to Generated Code With javax.tools.JavaCompiler
see https://dzone.com/articles/java-reflection-but-faster



Implement Service Affinity


@ModelMethod
Further split functionalities, roles, object, subject types
Refractor all Delegate init() methods to look like get(this::addRealm);
All Delegates should use the internal maps for storage
Create StorageInterfaces and incrementally rewrite Model Methods
Model Abstraction, see: eaa
Improve Logging
App dependendies(with version) declaration

Realm
Cache

name, reqiresApplication, Form

SPI Delegate tasks
    init():
    A config flag should exist to tell if a realm's form data has been stored.
    If so, or not, do the appropriate
     




* Discover, * Map functionalities


Sessions : 108, 112 Depends on Cache SPI and were commented out

Find a better alternative to getCanonicalFunctionality()
rename SPIDelegate.get to forEach, i.e init()
Cache, Storage, Models.start(), UI, , KeyStoreManager, Payments, Reporting, Metrics,
ClusteringError.from
CloudEnvironment.applies()
Errors should use RBKeys instead

Deal with the issue of multiple RB keys


Create mechanism to set default application per SpiType

Add support for SockJS

failureHandler

.failureHandler(ctx -> {
			if (ctx.statusCode() == HttpServletResponse.SC_NOT_FOUND) {
				ctx.reroute("/404");
			} else if (ctx.statusCode() == HttpServletResponse.SC_INTERNAL_SERVER_ERROR) {
				ctx.reroute("/error");
			} else {
				ctx.next();
			}
		});


CorsHandler

// The handler adds a CSRF token to requests which mutate state. In
// order change the state a (XSRF-TOKEN) cookie is set with a unique
// token, that is expected to be sent back in a (X-XSRF-TOKEN) header.
CSRFHandler

// The handler prevents DDOS attacks

BodyHandler



Create custom font cache provider for PDF library

Add TaskImages, enhance existing ones

Agent Availability Schedule

Probe cache=true in fusion

Start Jvm with --illegal-access=permit

